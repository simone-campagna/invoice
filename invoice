#!/usr/bin/env python3

__author__ = "Simone Campagna"

import argparse
import collections
import datetime
import glob
import logging
import math
import os
import re
import subprocess
import sys
import traceback

Invoice = collections.namedtuple('Invoice', (
    'doc_filename',
    'year',
    'number',
    'name',
    'tax_code',
    'city',
    'date',
    'income',
    'currency',
))

class WeekManager(object):
    Week = collections.namedtuple('Week', ('week_number', 'week_day'))
    def __init__(self):
        self._year_weeks = {}
        self._year_days = {}

    def year_setup(self, year):
        self._year_days[year] = []
        self._year_weeks[year] = []
        jan1 = datetime.date(year, 1, 1)
        dec31 = datetime.date(year, 12, 31)
        one_day = datetime.timedelta(days=1)
        six_days = datetime.timedelta(days=6)
        week_number = 1
        week_day = jan1.weekday()
        week_first = jan1
        week_last = week_first + one_day * (6 - week_day)
        year_weeks = self._year_weeks[year]
        year_weeks.append((week_first, week_last))
        while week_last < dec31:
            week_first = week_last + one_day
            week_last = min(week_first + six_days, dec31)
            year_weeks.append((week_first, week_last))
        year_days = self._year_days[year]
        for week_ordinal, (week_first, week_last) in enumerate(year_weeks):
            week_number = week_ordinal + 1
            d = week_first
            week_day = 0
            while d <= week_last:
                year_days.append(self.Week(week_number=week_number, week_day=week_day))
                week_day += 1
                d += one_day

    def get_year_weeks(self, year):
        if not year in self._year_weeks:
            self.year_setup(year)
        return self._year_weeks[year]

    def get_year_days(self, year):
        if not year in self._year_days:
            self.year_setup(year)
        return self._year_days[year]

    def week_range(self, year, week_number):
        year_weeks = self.get_year_weeks(year)
        return year_weeks[week_number - 1]

    def year_day(self, day):
        return day.timetuple().tm_yday

    def week(self, day):
        year_days = self.get_year_days(day.year)
        return year_days[self.year_day(day)]

    def week_day(self, day):
        return self.week(day).week_day

    def week_number(self, day):
        return self.week(day).week_number

class InvoiceError(Exception):
    pass

def get_logging_level(verbose_level):
    if verbose_level == 0:
        return logging.WARNING
    elif verbose_level == 1:
        return logging.INFO
    elif verbose_level >= 2:
        return logging.DEBUG

def create_logger(name, level=logging.WARNING, formatter=None):
    logger = logging.getLogger(name)
    handler = logging.StreamHandler()
    if formatter is None:
        formatter = logging.Formatter("%(levelname)s: %(message)s")
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(level)
    return logger

class InvoiceReader(object):
    RE_INVOICE_NUMBER = re.compile("^[Ff]attura\s+n.\s+(?P<year>\d+)/(?P<number>\d+)\s*$")
    RE_NAME = re.compile("^\s*[Ss]pett\.(?:\s*[Ss]ig\.?)?\s*(?P<name>[\w\s']+)\s*$")
    RE_TAX_CODE = re.compile("^.*(?P<tax_code>[A-Z]{6,6}\d\d[A-Z]\d\d[A-Z]\d\d\d[A-Z])\s*$")
    RE_DATE = re.compile("^\s*(?P<city>[^,]+)(?:,|\s)\s*(?P<date>\d{1,2}/\d{1,2}/\d\d\d\d)\s*$")
    RE_TOTAL = re.compile("Totale\s+fattura\s+(?P<income>[\d,\.]*)\s+(?P<currency>\w+)\s*$")
    DATE_FORMATS = (
        "%d/%m/%Y",
    )
    def __init__(self, logger):
        if logger is None:
            logger = logging.getLogger("root")
        self.logger = logger
        
    def read(self, doc_filename):
        got_number = False
        got_date = False
        got_name = False
        got_tax_code = False
        got_total = False
        data = {field: None for field in Invoice._fields}
        data['doc_filename'] = doc_filename
        converters = {
            'year': int,
            'number': int,
            'name': self.convert_name,
            'tax_code': self.convert_tax_code,
            'city': str,
            'date': self.convert_date,
            'income': self.convert_income,
            'currency': str,
        }
        def store(data, converters, match):
            data.update({key: converters[key](val) for key, val in match.groupdict().items()})
        for line in self.read_text(doc_filename).split('\n'):
            if not got_number:
                match = self.RE_INVOICE_NUMBER.match(line)
                if match:
                    got_number = True
                    store(data, converters, match)
                    continue
            if not got_name:
                match = self.RE_NAME.match(line)
                if match:
                    got_name = True
                    store(data, converters, match)
                    continue
            if not got_tax_code:
                match = self.RE_TAX_CODE.match(line)
                if match:
                    got_tax_code = True
                    store(data, converters, match)
                    continue
            if not got_date:
                match = self.RE_DATE.match(line)
                if match:
                    got_date = True
                    store(data, converters, match)
                    continue
            if not got_total:
                match = self.RE_TOTAL.match(line)
                if match:
                    got_total = True
                    store(data, converters, match)
                    continue
        self.logger.debug("year: {year} no: {number}, city: {city}, date: {date}, name: {name}, tax_code: {tax_code}, income: {income}, currency: {currency}".format(**data))
        return Invoice(**data)

    @classmethod
    def convert_name(cls, income_s):
        return ' '.join(item.title() for item in income_s.split())

    @classmethod
    def convert_tax_code(cls, income_s):
        return income_s.upper().strip()

    @classmethod
    def convert_income(cls, income_s):
        return float(income_s.replace('.', '').replace(',', '.'))

    @classmethod
    def convert_date(cls, date_s):
        for date_fmt in cls.DATE_FORMATS:
            try:
                datet = datetime.datetime.strptime(date_s, date_fmt)
            except ValueError as err:
                continue
            return datet.date()
        return None
           
    def read_text(self, doc_filename):
        cmdline = ["catdoc", doc_filename, "-f", "ascii", "-w"]
        p = subprocess.Popen(cmdline, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        return p.communicate()[0].decode("utf-8")
        
class InvoiceCollection(object):
    def __init__(self, init=None, logger=None):
        self._invoices = []
        self._processed = False
        self._years = []
        self._week_manager = WeekManager()
        if logger is None:
            logger = logging.getLogger("root")
        self.logger = logger
        if init:
            for invoice in init:
                self.add(invoice)

    @classmethod
    def compile_filter_function(cls, function_source):
        def filter(invoice):
            locals().update(datetime=datetime, **invoice._asdict())
            return eval(function_source)
        return filter

    def __iter__(self):
        return iter(self._invoices)

    def __len__(self):
        return len(self._invoices)

    def add(self, invoice):
        if not isinstance(invoice, Invoice):
            raise TypeError("invalid object {!r} of type {} (not an Invoice)".format(invoice, type(invoice).__name__))
        self._invoices.append(invoice)

    def filter(self, function):
        if isinstance(function, str):
            function = self.compile_filter_function(function)
        return InvoiceCollection(filter(function, self._invoices), logger=self.logger)

    @classmethod
    def subst_None(cls, value, substitution):
        if value is None:
            return substitution
        else:
            return value

    def process(self):
        if not self._processed:
            self._invoices.sort(key=lambda invoice: self.subst_None(invoice.number, -1))
            self._invoices.sort(key=lambda invoice: self.subst_None(invoice.year, -1))
            self._years = tuple(sorted(set(invoice.year for invoice in self._invoices if invoice.year is not None)))
            self._processed = True

    def years(self):
        return self._years

    def validate(self, werror=False, raise_on_error=False):
        self.process()
        result = dict(errors=0, warnings=0)
        def log_error(message):
            self.logger.error(message)
            if raise_on_error:
                raise InvoiceError(message)
            result['errors'] += 1
        if werror:
            log_warning = log_error
        else:
            def log_warning(message):
                self.logger.warning(message)
                result['warnings'] += 1

        # verify fields definition:
        for invoice in self._invoices:
            for key in 'year', 'number', 'name', 'tax_code', 'date', 'income':
                val = getattr(invoice, key)
                if val is None:
                    log_error("invoice {}: {} is undefined".format(invoice.doc_filename, key))
            if invoice.currency != 'euro':
                log_error("invoice {}: unsupported currency {!r}".format(invoice.doc_filename, invoice.currency))
            if invoice.date is not None and invoice.date.year != invoice.year:
                log_error("invoice {}: date {} does not match with year {}".format(invoice.doc_filename, invoice.date, invoice.year))

        # verify first/last name exchange:
        nd = {}
        for invoice in self._invoices:
            nd.setdefault(invoice.tax_code, set()).add(invoice.name)
        for tax_code, names in nd.items():
            if len(names) > 1:
                log_warning("#{} names ({}) refer to the same tax_code {}: possible first/last name exchange".format(len(names), ', '.join(repr(name) for name in names), tax_code))

        # verify numbering and dates per year
        for year in self.years():
            invoices = self.filter(lambda invoice: invoice.year == year)
            expected_number = 0
            prev_doc, prev_date = None, None
            for invoice in invoices:
                expected_number += 1
                if invoice.number != expected_number:
                    log_error("invoice {}: number {} is not valid (expected number for year {} is {})".format(invoice.doc_filename, invoice.number, year, expected_number))
                if prev_date is not None:
                    if invoice.date < prev_date:
                        log_error("invoice {}: date {} is lower than previous invoice {} ({})".format(invoice.doc_filename, invoice.date, prev_doc, prev_date))
                prev_doc, prev_date = invoice.doc_filename, invoice.date
        return result

    def list(self, print_function=print):
        self.process()
        digits = 1 + int(math.log10(max(1, len(self._invoices))))
        for invoice in self._invoices:
            print_function("""\
invoice:                  {doc_filename!r}
  year/number:            {year}/{number:0{digits}d}
  city/date:              {city}/{date}
  name:                   {name}
  tax code:               {tax_code}
  total income:           {income:.2f} [{currency}]""".format(digits=digits, **invoice._asdict()))

    def report(self, print_function=print):
        self.process()
        for year in self.years():
            year_invoices = self.filter(lambda invoice: invoice.year == year)
            td = {}
            wd = {}
            for invoice in year_invoices:
                td.setdefault(invoice.tax_code, []).append(invoice)
                wd.setdefault(self.get_week_number(invoice.date), []).append(invoice)
            print_function("""\
year {year}:
  * number_of invoices:   {num_invoices}
  * number of clients:    {num_clients}\
""".format(
                year=year,
                num_invoices=len(year_invoices),
                num_clients=len(td),
            ))
            total_income = sum(invoice.income for invoice in year_invoices)
            for tax_code, invoices in td.items():
                client_total_income = sum(invoice.income for invoice in invoices)
                if total_income != 0.0:
                    client_income_percentage = client_total_income / total_income
                else:
                    client_income_percentage = 0.0
                client_weeks = sorted(set(self.get_week_number(invoice.date) for invoice in invoices))
                print("""\
    + client:             {tax_code} ({name}):
      number of invoices: {num_invoices}
      total income:       {client_total_income}
      income percentage:  {client_income_percentage:.2%}
      weeks:              {client_weeks}
""".format(
                    tax_code=tax_code,
                    name='|'.join(name for name in set(invoice.name for invoice in invoices)),
                    num_invoices=len(invoices),
                    total_income=total_income,
                    client_total_income=client_total_income,
                    client_income_percentage=client_income_percentage,
                    client_weeks=', '.join(repr(week) for week in client_weeks),
                ))
            print_function("""\
  * number of weeks:      {num_weeks}\
""".format(
                num_weeks=len(wd),
            ))
            for week in sorted(wd.keys()):
                invoices = wd[week]
                week_total_income = sum(invoice.income for invoice in invoices)
                if total_income != 0.0:
                    week_income_percentage = week_total_income / total_income
                else:
                    week_income_percentage = 0.0
                first_date, last_date = self.get_week_range(year, week)
                print("""\
    + week:               {week} [{first_date} -> {last_date}]:
      number of invoices: {num_invoices}
      total income:       {week_total_income}
      income percentage:  {week_income_percentage:.2%}
""".format(
                    week=week,
                    num_invoices=len(invoices),
                    first_date=first_date,
                    last_date=last_date,
                    total_income=total_income,
                    week_total_income=week_total_income,
                    week_income_percentage=week_income_percentage,
                ))
        
    def get_week_number(self, day):
        return self._week_manager.week_number(day)

    def get_week_range(self, year, week_number):
        return self._week_manager.week_range(year=year, week_number=week_number)

class InvoiceCollectionReader(object):
    def __init__(self, trace=False, logger=None):
        if logger is None:
            logger = logging.getLogger("root")
        self.logger = logger
        self.trace = trace

    def read(self, *doc_filename_patterns):
        invoice_reader = InvoiceReader(logger=self.logger)
        invoice_collection = InvoiceCollection(logger=self.logger)
        for doc_filename_pattern in doc_filename_patterns:
            for doc_filename in glob.glob(doc_filename_pattern):
                try:
                    invoice_collection.add(invoice_reader.read(doc_filename))
                except Exception as err:
                    if self.trace:
                        traceback.print_exc()
                    
                    self.logger.error("cannot read invoice from {!r}: {}: {}".format(doc_filename, type(err).__name__, err))
        return invoice_collection
          

def main():
    parser = argparse.ArgumentParser(
    description="""\
Read and process a collection of invoices.

Each input invoice is a DOC file.
The 'catdoc' tool is used to convert DOC files; it must be available.

For each DOC file, the following information is retrieved:
  * 'year'
  * 'number'
  * 'city'
  * 'date'
  * 'name'
  * 'tax_code'
  * 'income'
  * 'currency'

The read invoices are validated in order to detect typical errors, such
as:
  * wrong dates ordering
  * wrong numbering
  * missing information

The read invoices can then be filtered by passing some filtering
function, for instance:
  * -f 'number > 10'

It is then possible to apply an action to the parsed invoices:
* --list, -l: all the invoices are listed
* --report, -r: a per-year report is shown.

""",
        epilog="""\
Please, donate 10% of the total income to the author {!r}!
""".format(__author__),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    default_validate = True

    parser.add_argument("--filter", "-f",
        metavar="F",
        dest="filters",
        type=str,
        action="append",
        default=[],
        help="add a filter (e.g. 'year == 2014')")

    parser.add_argument("--disable-validation", "-V",
        dest="validate",
        action="store_false",
        default=default_validate,
        help="do not validate invoices")

    action_group = parser.add_mutually_exclusive_group()

    action_group.add_argument("--list", "-l",
        action="store_true",
        default=False,
        help="list invoices")

    action_group.add_argument("--report", "-r",
        action="store_true",
        default=False,
        help="show invoice report")

    parser.add_argument("--trace", "-t",
        action="store_true",
        default=False,
        help="show traceback on errors invoices")

    parser.add_argument("--werror", "-w",
        action="store_true",
        default=False,
        help="make all warnings into errors")

    parser.add_argument("--raise", "-R",
        dest="raise_on_error",
        action="store_true",
        default=False,
        help="make first error be fatal")

    parser.add_argument("--verbose", "-v",
        dest="verbose_level",
        action="count",
        default=0,
        help="increase verbose level")

    parser.add_argument("patterns",
        nargs='+',
        help='doc patterns',
    )

    args = parser.parse_args()

    logger = create_logger(name='root', level=get_logging_level(args.verbose_level))

    invoice_collection_reader = InvoiceCollectionReader(trace=args.trace)

    invoice_collection = invoice_collection_reader.read(*args.patterns)

    if args.validate is None:
        args.validate = any([args.report])

    try:
        if args.validate:
            logger.info("validating {} invoices...".format(len(invoice_collection)))
            result = invoice_collection.validate(werror=args.werror, raise_on_error=args.raise_on_error)
            if result['errors']:
                logger.error("found #{} errors - exiting".format(result['errors']))
                return 1
    
        if args.filters:
            logger.info("filtering {} invoices...".format(len(invoice_collection)))
            for filter_source in args.filters:
                logger.info("applying filter {!r} to {} invoices...".format(filter_source, len(invoice_collection)))
                invoice_collection = invoice_collection.filter(filter_source)
        
    
        if args.list:
            logger.info("listing {} invoices...".format(len(invoice_collection)))
            invoice_collection.list()
    
        if args.report:
            logger.info("producing report for {} invoices...".format(len(invoice_collection)))
            invoice_collection.report()
    
    except Exception as err:
        if args.trace:
            traceback.print_exc()
        logger.error("{}: {}\n".format(type(err).__name__, err))

    return 0

if __name__ == "__main__":
    sys.exit(main())
